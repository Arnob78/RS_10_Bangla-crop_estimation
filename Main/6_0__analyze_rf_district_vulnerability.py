import os
import rasterio
import geopandas as gpd
import numpy as np
import pandas as pd
from rasterio.mask import mask
from tqdm import tqdm
import matplotlib.pyplot as plt

def main():
    # --- Configuration ---
    try:
        SCRIPT_NAME, _ = os.path.splitext(os.path.basename(__file__))
    except NameError:
        SCRIPT_NAME = "10__get_rf_location_vulnerability"

    PROJECT_ROOT = r"C:\Users\NagaiLab\GC_Project_work\submitted_RS_10_Bangla-crop_estimation"
    
    # Use the NEW Random Forest map
    RASTER_PATH = os.path.join(PROJECT_ROOT, "8__generate_rf_vulnerability_map", "rf_crop_vulnerability_map.tif")
    
    # Shapefile for districts - CORRECTED PATH
    SHAPEFILE_PATH = os.path.join(PROJECT_ROOT, "data", "shapefile", "BGD_adm", "BGD_adm2.shp")

    # --- Output ---
    OUTPUT_DIR = os.path.join(PROJECT_ROOT, SCRIPT_NAME)
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    OUTPUT_CSV = os.path.join(OUTPUT_DIR, "district_vulnerability_scores.csv")
    OUTPUT_PLOT_PNG = os.path.join(OUTPUT_DIR, "district_vulnerability_barchart.png")

    print(f"--- Calculating and Plotting Mean Vulnerability per District ---")
    print(f"Reading vulnerability map: {RASTER_PATH}")
    print(f"Reading district shapefile: {SHAPEFILE_PATH}")

    # 1. Load the data
    try:
        gdf = gpd.read_file(SHAPEFILE_PATH)
        src = rasterio.open(RASTER_PATH)
    except Exception as e:
        print(f"FATAL ERROR: Could not read input files. {e}")
        return

    # Ensure CRS matches
    if gdf.crs != src.crs:
        print("Warning: CRS mismatch. Reprojecting shapefile...")
        gdf = gdf.to_crs(src.crs)

    # 2. Calculate mean vulnerability for each district
    results = []
    print("\nProcessing districts...")
    for index, row in tqdm(gdf.iterrows(), total=gdf.shape[0]):
        # Use the correct column name for the district
        district_name = row['NAME_2']
        geom = [row['geometry']]
        
        try:
            out_image, out_transform = mask(src, geom, crop=True)
            nodata = src.nodata
            valid_pixels = out_image[out_image != nodata]
            
            if valid_pixels.size > 0:
                results.append({
                    'District': district_name,
                    'Mean_Vulnerability': np.mean(valid_pixels),
                    'Median_Vulnerability': np.median(valid_pixels),
                    'Std_Dev': np.std(valid_pixels),
                    'Pixel_Count': valid_pixels.size
                })
        except Exception as e:
            print(f"Could not process district {district_name}. Error: {e}")
            continue
            
    src.close()
    
    # 3. Create and save DataFrame
    if not results:
        print("\nNo results were generated. Exiting.")
        return

    df = pd.DataFrame(results)
    df = df.sort_values(by='Mean_Vulnerability', ascending=False)

    print("\n--- Top 10 Districts by Mean Vulnerability ---")
    print(df.head(10).to_string())

    print(f"\nSaving full results to: {OUTPUT_CSV}")
    df.to_csv(OUTPUT_CSV, index=False)

    # 4. Create and save the bar chart from the dataframe
    print("\n--- Creating Bar Chart Visualization ---")
    top_n = 30
    df_plot = df.head(top_n)

    print(f"Plotting top {top_n} most vulnerable districts.")

    plt.style.use('seaborn-v0_8-whitegrid')
    # Increase figure size to accommodate larger fonts
    fig, ax = plt.subplots(figsize=(12 * 1.5, 14 * 1.5)) 

    # Create horizontal bars
    y_pos = np.arange(len(df_plot))
    bars = ax.barh(y_pos, df_plot['Mean_Vulnerability'], align='center', color='firebrick', alpha=0.8)
    
    ax.set_yticks(y_pos)
    ax.set_yticklabels(df_plot['District'])
    ax.invert_yaxis()  # Invert to show highest vulnerability at the top

    # Add labels and title with increased font sizes
    font_factor = 1.7
    ax.set_xlabel('Mean Vulnerability Score (Z-Score)', fontsize=14 * font_factor)
    ax.set_title(f'Top {top_n} Most Vulnerable Districts in Bangladesh (by Mean Z-Score)', fontsize=16 * font_factor, weight='bold')
    ax.tick_params(axis='both', which='major', labelsize=12 * font_factor)

    # Add value labels, with conditional logic for positive/negative bars
    for bar in bars:
        width = bar.get_width()
        
        # If the bar is negative, place label to the left
        if width < 0:
            ax.text(width - 0.01, 
                    bar.get_y() + bar.get_height()/2.,
                    f'{width:.2f}',
                    ha='right', 
                    va='center',
                    fontsize=10 * font_factor,
                    color='black')
        # If the bar is positive, place label to the right
        else:
            ax.text(width + 0.01, 
                    bar.get_y() + bar.get_height()/2.,
                    f'{width:.2f}',
                    ha='left', 
                    va='center',
                    fontsize=10 * font_factor,
                    color='black')

    plt.tight_layout()

    # Save the figure in the same output directory
    print(f"Saving bar chart to: {OUTPUT_PLOT_PNG}")
    plt.savefig(OUTPUT_PLOT_PNG, dpi=300)
    plt.close()

    print(f"\n--- Script {SCRIPT_NAME}.py finished successfully. ---")


if __name__ == "__main__":
    main()
